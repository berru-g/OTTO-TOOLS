<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: Arial, sans-serif;
            justify-content: center;
            align-items: center;
            height: 60vh;
            margin: 20;
            background-color: #f5f5f5;
        }

        #encoderCanvas {
            max-width: 60%;
            max-height: 300px;
            margin-top: 10px;
        }

        .box {
            text-align: center;
            background-color: white;
            border: 2px dashed #ccc;
            padding: 20px 20px;
            border-radius: 10px;
        }

        textarea {
            width: 200px;
            height: 100px;
        }
    </style>

</head>
<body>
<div class="box" id="encoder">
    <div id="dropzone" class="dropzone">
        <h1>St√©gano</h1>
        <h2>Encoder</h2>
        <canvas id="encoderCanvas"></canvas>
        <label>
            <input type="file" id="upload" name="upload" />
        </label>
        <button id="encode">Encode</button>
        <a id="save" download="MyEncodedImage.png" href="#" target="_blank">
            <button id="download">Download</button>
        </a>
        <textarea id="secret">Put text to be encoded here</textarea>
    </div>

    <div class="box" id="decoder">
        <h2>Decoder</h2>
        <input type="file" id="decodeUpload" />
        <canvas id="decoderCanvas"></canvas>
        <textarea id="notSecretAnymore" readonly>Decoded text will be here</textarea>
    </div>
    <script>
        var s, Canvas = {
            settings: {
                height: 200,
                width: 200
            },
            canvas: document.getElementById('encoderCanvas'),
            encodeButton: document.getElementById('encode'),
            uploadButton: document.getElementById('upload'),
            downloadButton: document.getElementById('download'),
            save: document.getElementById('save'),
            textArea: document.getElementById('secret'),
            context: null,

            init: function () {
                s = this.settings;
                this.context = this.canvas.getContext('2d');
                this.bindUIActions();
            },

            bindUIActions: function () {
                this.uploadButton.addEventListener('change', this.imageUpload, false);
                this.encodeButton.addEventListener('click', this.encode, false);
                this.downloadButton.addEventListener('click', function (e) {
                    var dataURL = Canvas.canvas.toDataURL('image/png');
                    Canvas.save.href = dataURL;
                });
            },

            encode: function () {
                text = string2Bin(Canvas.textArea.value)
                text = text.join('');
                Canvas.placeInImage(text);
            },

            imageUpload: function (e) {
                var reader = new FileReader();
                reader.onload = function (event) {
                    var img = new Image();
                    img.onload = function () {
                        img = Canvas.scaleImageToBoundingBox(img);
                        Canvas.context.drawImage(img, 0, 0, img.width, img.height);
                    }
                    img.src = event.target.result;
                }
                reader.readAsDataURL(e.target.files[0]);
            },

            scaleImageToBoundingBox: function (img) {
                var scale = img.width / img.height;
                if (scale > 1) {
                    img.width = s.width;
                    img.height = img.width / scale;
                } else {
                    img.height = s.height;
                    img.width = img.height * scale;
                }

                Canvas.canvas.width = img.width;
                Canvas.canvas.height = img.height;

                return img;
            },

            placeInImage: function (stringToHide) {
                var imageData = this.context.getImageData(0, 0, s.width, s.height);
                var pixels = imageData.data;

                for (var i = 0, n = pixels.length; i < n, i / 4 * 3 < stringToHide.length; i += 4) {
                    stringOffset = i / 4 * 3;
                    pixels[i] = stegano(pixels[i], stringToHide[stringOffset]);
                    pixels[i + 1] = stegano(pixels[i + 1], stringToHide[stringOffset + 1]);
                    pixels[i + 2] = stegano(pixels[i + 2], stringToHide[stringOffset + 2]);
                }

                this.context.putImageData(imageData, 0, 0);
            },
        }





        var d, DecoderCanvas = {
            settings: {
                height: 500,
                width: 500
            },
            canvas: document.getElementById('decoderCanvas'),
            context: null,
            imageLoader: document.getElementById('decodeUpload'),
            decodedText: document.getElementById('notSecretAnymore'),

            init: function () {
                d = this.settings;
                this.context = this.canvas.getContext('2d');
                this.bindUIActions();
            },

            bindUIActions: function () {
                this.imageLoader.addEventListener('change', this.imageUpload, false);
            },

            imageUpload: function (e) {
                var reader = new FileReader();
                reader.onload = function (event) {
                    var img = new Image();
                    img.onload = function () {
                        DecoderCanvas.context.drawImage(img, 0, 0, img.width, img.height);
                        DecoderCanvas.readFromImage();
                    }
                    img.src = event.target.result;
                }
                reader.readAsDataURL(e.target.files[0]);
            },

            readFromImage: function () {
                var imageData = this.context.getImageData(0, 0, s.width, s.height);
                var pixels = imageData.data;
                var binary = [];
                var text = [];

                for (var i = 0, n = pixels.length; i < n; i += 4) {
                    binary.push(readParity(pixels[i]));
                    binary.push(readParity(pixels[i + 1]));
                    binary.push(readParity(pixels[i + 2]));
                }

                binary = binary.join('');

                for (var i = 0, n = binary.length; i < n; i += 8) {
                    text.push(binary.substring(i, i + 8));
                }

                DecoderCanvas.decodedText.value = bin2String(text);
            },
        }

















        function set8Digits(str) {
            var pad = "00000000";
            return pad.substring(0, pad.length - str.length) + str;
        }

        function string2Bin(str) {
            var result = [];
            for (var i = 0; i < str.length; i++) {
                result.push(set8Digits((str.charCodeAt(i) >>> 0).toString(2)));
            }
            return result;
        }

        function bin2String(array) {
            array = array.map(num => parseInt(num, 2));
            return String.fromCharCode.apply(String, array);
        }

        function stegano(num, parity) {
            if (num % 2 == parity) {
                return num;
                //seperate cases to prevent overflow on 255/0 value
            } else if (parity == 1) {
                return num + 1;
            } else if (parity == 0) {
                return num - 1
            }
        }

        function readParity(num) {
            return num % 2;
        }

        Canvas.init();
        DecoderCanvas.init();
    </script>
</body>
</html>